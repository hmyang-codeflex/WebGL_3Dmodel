<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Babylon 3D ë·°ì–´ - Popup Version</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <style>
    html, body {
      height:100%; margin:0;
      background:#f7f8fa; color:#222; font-family:'Segoe UI', 'Roboto', 'Apple SD Gothic Neo', 'Noto Sans KR', Arial, sans-serif;
    }
    #app { 
      position:fixed; 
      inset:0; 
      background:#fff; 
    }
    canvas { 
      width:100%; 
      height:100%; 
      display:block; 
      background:#fff; 
      border-radius:12px; 
      box-shadow:0 2px 16px 0 rgba(60,80,120,0.08); 
    }
    #hoverInfoPanel {
      position: absolute;
      right: 20px;
      top: 20px;
      z-index: 1000;
      border: 1px solid #e3e7ee;
      border-radius: 16px;
      padding: 18px 14px;
      background: #fff;
      display: none;
      box-shadow: 0 2px 8px 0 rgba(60,80,120,0.04);
      max-width: 300px;
    }
    #hoverInfoPanel h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      font-weight: 600;
      color: #3a4153;
    }
    #hoverInfoPanel div {
      font-size: 12px;
      color: #7a869a;
      margin-bottom: 4px;
    }

    /* ìƒë‹¨ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ë“¤ */
    .top-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      gap: 10px;
    }

    .control-btn {
      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #e3e7ee;
      border-radius: 8px;
      color: #3a4153;
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(60,80,120,0.15);
      backdrop-filter: blur(8px);
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 12px rgba(60,80,120,0.25);
      transform: translateY(-1px);
    }

    .control-btn:active {
      transform: translateY(0);
    }

    #fileInput {
      display: none;
    }

    /* í™œì„± ëª¨ë“œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .mode-btn-active {
      background: #4f46e5 !important;
      color: white !important;
      box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3) !important;
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="renderCanvas"></canvas>
    
    <!-- ìƒë‹¨ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ë“¤ -->
    <div class="top-controls">
      <label for="fileInput" class="control-btn">ğŸ“‚ ëª¨ë¸ ì—´ê¸°</label>
      <button id="modelInfoBtn" class="control-btn">ğŸ“Š ëª¨ë¸ ì •ë³´</button>
      <button id="settingsBtn" class="control-btn">âš™ï¸ ì„¤ì •</button>
    </div>
    
    <!-- ìˆ¨ê²¨ì§„ íŒŒì¼ ì…ë ¥ -->
    <input type="file" id="fileInput" accept=".glb,.gltf,.GLB,.GLTF,.bin" multiple>
  </div>

  <script>
    /*
    =================================================================
                        WebGL 3D ë·°ì–´ - íŒì—… ë²„ì „
    =================================================================
    ì£¼ ì‚¬ìš© ëª¨ë¸: urdf_colored_metallic.glb (ë¡œë´‡ íŒ” ì‹œìŠ¤í…œ)
    ì¢Œí‘œê³„: URDF â†’ glTF ë³€í™˜ ì™„ë£Œ (Xì¶• -90ë„ íšŒì „, Z=0 ê¸°ì¤€ì )
    ê¸°ëŠ¥: 3D ëª¨ë¸ ë¡œë“œ/ì¡°ì‘, ê¸°ì¦ˆëª¨ ì œì–´, ê²½ê³„ë°•ìŠ¤ í‘œì‹œ
    ëª¨ë¸ ì •ë³´ì°½: ë³„ë„ íŒì—…ìœ¼ë¡œ ì—´ë¦¼
    =================================================================
    */
    
    // ===== ê¸°ë³¸ Babylon ì„¸íŒ… =====
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });
    const scene  = new BABYLON.Scene(engine);
    
    // ê¸°ë³¸ ë°°ê²½ìƒ‰ (ì´ˆê¸°ê°’)
    scene.clearColor = new BABYLON.Color4(0x0f/255, 0x11/255, 0x15/255, 1);

    const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/4, Math.PI/3, 3, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 0.01; 
    camera.wheelPrecision = 30;

    new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene).intensity = 0.7;
    const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-5,-10,-7), scene); 
    dir.intensity = 1.0;

    // localStorage ìœ í‹¸
    function getLS(key, def) {
      try { const v = localStorage.getItem(key); return v !== null ? v : def; } catch(e) { return def; }
    }
    function setLS(key, val) {
      try { localStorage.setItem(key, val); } catch(e) {}
    }

    // ë°”ë‹¥ ê·¸ë¦¬ë“œ
    let gridSize = parseFloat(getLS('gridSize', '10'));
    let ground = BABYLON.Mesh.CreateGround("grid", gridSize, gridSize, 2, scene);
    let gridMat = new BABYLON.GridMaterial("gridMat", scene);
    gridMat.mainColor = BABYLON.Color3.FromHexString(getLS('gridMainColor', '#232531'));
    gridMat.lineColor = BABYLON.Color3.FromHexString(getLS('gridLineColor', '#3a4153'));
    ground.material = gridMat;

    // ===== ìƒíƒœ ë³€ìˆ˜ë“¤ =====
    let rootContainer = new BABYLON.TransformNode("rootContainer", scene); // ë©”ì¸ ëª¨ë¸ ì»¨í…Œì´ë„ˆ
    let currentContainer = null;
    let spaceLocal = true; // ë¡œì»¬/ì›”ë“œ ì¢Œí‘œê³„ ëª¨ë“œ
    let hl = null;
    let modelInfoWindow = null; // ëª¨ë¸ ì •ë³´ íŒì—… ìœˆë„ìš° ì°¸ì¡°

    // ===== 3D ì¡°ì‘ ê¸°ì¦ˆëª¨ ì‹œìŠ¤í…œ =====
    const gizmoManager = new BABYLON.GizmoManager(scene);
    gizmoManager.boundingBoxGizmoEnabled = false;
    gizmoManager.positionGizmoEnabled = true;
    gizmoManager.usePointerToAttachGizmos = false;

    let currentMode = 'translate';

    function setMode(mode){
      currentMode = mode;
      gizmoManager.positionGizmoEnabled = (mode === 'translate');
      gizmoManager.rotationGizmoEnabled = (mode === 'rotate');
      gizmoManager.scaleGizmoEnabled    = (mode === 'scale');
      
      console.log(`Mode changed to: ${mode}`);
      
      // ëª¨ë¸ ì •ë³´ íŒì—…ì— ëª¨ë“œ ë³€ê²½ ì•Œë¦¼
      if (modelInfoWindow && !modelInfoWindow.closed) {
        modelInfoWindow.postMessage({
          type: 'modeChanged',
          data: { mode: mode }
        }, '*');
      }
    }
    
    function setSpace(local){
      spaceLocal = !!local;
      const follow = spaceLocal;
      if (gizmoManager.positionGizmo) gizmoManager.positionGizmo.updateGizmoRotationToMatchAttachedMesh = follow;
      if (gizmoManager.rotationGizmo) gizmoManager.rotationGizmo.updateGizmoRotationToMatchAttachedMesh = follow;
      if (gizmoManager.scaleGizmo)    gizmoManager.scaleGizmo.updateGizmoRotationToMatchAttachedMesh = follow;
    }
    
    setMode('translate'); 
    setSpace(true);

    // ===== ìœ í‹¸ í•¨ìˆ˜ë“¤ =====
    function attachKeepWorld(child, parent){
      const wm = child.getWorldMatrix().clone();
      child.setParent(parent);
      const s = new BABYLON.Vector3(), r = new BABYLON.Quaternion(), t = new BABYLON.Vector3();
      wm.decompose(s, r, t);
      child.rotationQuaternion = r;
      child.scaling = s; 
      child.position = t;
      child.computeWorldMatrix(true);
    }

    function computeBounds(node){
      let meshes = node.getChildMeshes ? node.getChildMeshes(false) : [];
      if (node instanceof BABYLON.AbstractMesh) meshes = [node, ...meshes];
      if (meshes.length === 0) return null;
      let min = new BABYLON.Vector3(+Infinity,+Infinity,+Infinity);
      let max = new BABYLON.Vector3(-Infinity,-Infinity,-Infinity);
      for (const m of meshes){
        m.computeWorldMatrix(true);
        const bi = m.getBoundingInfo();
        const bmin = bi.boundingBox.minimumWorld;
        const bmax = bi.boundingBox.maximumWorld;
        min = BABYLON.Vector3.Minimize(min, bmin);
        max = BABYLON.Vector3.Maximize(max, bmax);
      }
      return {min, max, size: max.subtract(min), center: min.add(max).scale(0.5)};
    }

    function focusNode(node) {
      const b = computeBounds(node); 
      if (!b) return;
      
      // ì¹´ë©”ë¼ íƒ€ê²Ÿì„ ëª¨ë¸ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ì •
      camera.setTarget(b.center);
      
      // ì ì ˆí•œ ê±°ë¦¬ ê³„ì‚° (ëª¨ë¸ í¬ê¸°ì— ë”°ë¼)
      const maxDim = Math.max(b.size.x, b.size.y, b.size.z);
      camera.radius = Math.max(maxDim * 1.5, 0.1); // ìµœì†Œ ê±°ë¦¬ ë³´ì¥
      
      // ì¹´ë©”ë¼ ê°ë„ ì´ˆê¸°í™”
      camera.alpha = -Math.PI / 4;  // -45ë„
      camera.beta = Math.PI / 3;    // 60ë„
      
      console.log('Camera focused on bounds:', b, 'radius:', camera.radius);
    }

    // ===== ê°„ë‹¨í•œ ê¸°ì¦ˆëª¨ ê´€ë¦¬ (ì •ìƒ ì‘ë™í•˜ëŠ” viewer.html ë°©ì‹) =====
    function attachGizmoToModel() {
      if (!rootContainer) {
        console.warn('No rootContainer found');
        return;
      }
      
      // ê¸°ì¦ˆëª¨ë¥¼ ì§ì ‘ rootContainerì— ì—°ê²° (í”¼ë²— ì—†ì´)
      gizmoManager.attachToMesh(rootContainer);
      console.log('Gizmo attached directly to rootContainer');
    }

    // ===== ë§ˆìš°ìŠ¤ ì˜¤ë²„ ê²½ê³„ë°•ìŠ¤ í‘œì‹œ =====
    let hoverBoundingBox = null;
    let modelBoundingBox = null;
    
    function showHoverBoundingBox(mesh) {
      // ê¸°ì¡´ í˜¸ë²„ ë°•ìŠ¤ ì œê±°
      if (hoverBoundingBox) { 
        hoverBoundingBox.dispose(); 
        hoverBoundingBox = null; 
      }
      
      if (!mesh || !rootContainer) return;
      
      // ê°œë³„ ë©”ì‹œì˜ ê²½ê³„ë°•ìŠ¤ í‘œì‹œ
      const bounds = mesh.getBoundingInfo();
      hoverBoundingBox = BABYLON.MeshBuilder.CreateBox("hoverBoundingBox", {size:1}, scene);
      hoverBoundingBox.scaling = bounds.boundingBox.maximumWorld.subtract(bounds.boundingBox.minimumWorld);
      hoverBoundingBox.position = bounds.boundingBox.centerWorld;
      hoverBoundingBox.isPickable = false;
      hoverBoundingBox.visibility = 0.6;
      
      // í˜¸ë²„ ë°•ìŠ¤ ì¬ì§ˆ
      hoverBoundingBox.material = new BABYLON.StandardMaterial("hoverBoundingMat", scene);
      hoverBoundingBox.material.diffuseColor = new BABYLON.Color3(1, 0.8, 0); // ì£¼í™©ìƒ‰
      hoverBoundingBox.material.alpha = 0.3;
      hoverBoundingBox.material.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
      hoverBoundingBox.material.wireframe = true;
    }
    
    function showModelBoundingBox() {
      // ê¸°ì¡´ ëª¨ë¸ ë°•ìŠ¤ ì œê±°
      if (modelBoundingBox) { 
        modelBoundingBox.dispose(); 
        modelBoundingBox = null; 
      }
      
      if (!rootContainer) return;
      
      // ì „ì²´ ëª¨ë¸ì˜ ê²½ê³„ë°•ìŠ¤ í‘œì‹œ
      const bounds = computeBounds(rootContainer);
      if (bounds) {
        modelBoundingBox = BABYLON.MeshBuilder.CreateBox("modelBoundingBox", {size:1}, scene);
        modelBoundingBox.scaling = bounds.size;
        modelBoundingBox.position = bounds.center;
        modelBoundingBox.isPickable = false;
        modelBoundingBox.visibility = 0.8;
        
        // ëª¨ë¸ ë°•ìŠ¤ ì¬ì§ˆ
        modelBoundingBox.material = new BABYLON.StandardMaterial("modelBoundingMat", scene);
        modelBoundingBox.material.diffuseColor = new BABYLON.Color3(0, 0.8, 1); // ì²­ìƒ‰
        modelBoundingBox.material.alpha = 0.4;
        modelBoundingBox.material.emissiveColor = new BABYLON.Color3(0, 0.8, 1);
        modelBoundingBox.material.wireframe = true;
      }
    }
    
    function removeAllBoundingBoxes() {
      if (hoverBoundingBox) { 
        hoverBoundingBox.dispose(); 
        hoverBoundingBox = null; 
      }
      if (modelBoundingBox) { 
        modelBoundingBox.dispose(); 
        modelBoundingBox = null; 
      }
    }

    // ë§ˆìš°ìŠ¤ ë¬´ë¸Œ ì´ë²¤íŠ¸ - í˜¸ë²„ ê²½ê³„ë°•ìŠ¤ í‘œì‹œ
    canvas.addEventListener('mousemove', (e) => {
      const pick = scene.pick(scene.pointerX, scene.pointerY);
      if (pick?.hit && pick.pickedMesh && pick.pickedMesh !== ground) {
        showHoverBoundingBox(pick.pickedMesh);
      } else {
        if (hoverBoundingBox) { 
          hoverBoundingBox.dispose(); 
          hoverBoundingBox = null; 
        }
      }
    });

    // ===== ì „ì²´ ëª¨ë¸ ì„ íƒë§Œ ì§€ì› =====
    let selectedModel = null;

    canvas.addEventListener('click', ()=>{
      // í•­ìƒ ì „ì²´ ëª¨ë¸ ì„ íƒ
      if (rootContainer) {
        selectedModel = rootContainer;
        
        // ê¸°ì¦ˆëª¨ë¥¼ ì „ì²´ ëª¨ë¸ì— ì§ì ‘ ì—°ê²°
        gizmoManager.attachToMesh(rootContainer);
        
        // í˜„ì¬ ëª¨ë“œ ì¬ì ìš©
        setTimeout(() => {
          setMode(currentMode);
        }, 50);
        
        // ì „ì²´ ëª¨ë¸ ê²½ê³„ë°•ìŠ¤ í‘œì‹œ
        showModelBoundingBox();
        
        console.log(`Selected whole model, Mode: ${currentMode}`);
        
        // ëª¨ë¸ ì •ë³´ íŒì—…ì— ì„ íƒ ì •ë³´ ì „ë‹¬
        if (modelInfoWindow && !modelInfoWindow.closed) {
          sendModelInfoToPopup();
        }
      } else {
        selectedModel = null;
        gizmoManager.attachToMesh(null);
        removeAllBoundingBoxes();
      }
    });

    // ë”ë¸”í´ë¦­ìœ¼ë¡œ ì „ì²´ ëª¨ë¸ í¬ì»¤ìŠ¤
    canvas.addEventListener('dblclick', ()=>{
      if (selectedModel || rootContainer) {
        focusNode(rootContainer);
      }
    });

    // ===== í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤ =====
    window.addEventListener('keydown', (e)=>{
      if (['INPUT','TEXTAREA'].includes((e.target.tagName||''))) return;
      const k = e.key.toLowerCase();
      if (k==='w') {
        setMode('translate');
        console.log('Translation mode activated');
      }
      if (k==='e') {
        setMode('rotate');
        console.log('Rotation mode activated');
      }
      if (k==='r') {
        setMode('scale');
        console.log('Scale mode activated');
      }
      if (k==='l') setSpace(!spaceLocal);
      if (k==='f' && gizmoManager.attachedMesh) focusNode(gizmoManager.attachedMesh);
      if (k==='i') { // 'I'í‚¤ë¡œ ì •ë³´ íŒ¨ë„ í† ê¸€
        toggleModelInfoPopup();
      }
      if (k==='escape') { // ESCí‚¤ë¡œ íŒì—… ë‹«ê¸°
        if (modelInfoWindow && !modelInfoWindow.closed) {
          modelInfoWindow.close();
        }
      }
    });

    // ===== ëª¨ë¸ ì •ë³´ íŒì—… ê´€ë¦¬ =====
    function toggleModelInfoPopup() {
      if (modelInfoWindow && !modelInfoWindow.closed) {
        modelInfoWindow.close();
        modelInfoWindow = null;
      } else {
        openModelInfoPopup();
      }
    }

    function openModelInfoPopup() {
      if (!rootContainer) {
        alert('ë¡œë“œëœ ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ëª¨ë¸ì„ ë¡œë“œí•´ì£¼ì„¸ìš”.');
        return;
      }

      // ëª¨ë¸ì´ ì„ íƒë˜ì§€ ì•Šì€ ìƒíƒœë¼ë©´ ë¨¼ì € ì„ íƒ
      if (!selectedModel) {
        selectedModel = rootContainer;
        gizmoManager.attachToMesh(rootContainer);
      }

      // íŒì—… ìœˆë„ìš° ì—´ê¸°
      const popupWidth = 400;
      const popupHeight = 600;
      const left = window.screenX + window.outerWidth - popupWidth - 50;
      const top = window.screenY + 50;

      modelInfoWindow = window.open(
        'model-info.html',
        'modelInfo',
        `width=${popupWidth},height=${popupHeight},scrollbars=yes,resizable=yes,left=${left},top=${top}`
      );

      if (!modelInfoWindow) {
        alert('íŒì—…ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ íŒì—…ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
        return;
      }

      // íŒì—… ë¡œë“œ ì™„ë£Œ ëŒ€ê¸° í›„ ë°ì´í„° ì „ì†¡
      modelInfoWindow.addEventListener('load', function() {
        setTimeout(() => {
          sendModelInfoToPopup();
        }, 500);
      });
    }

    function sendModelInfoToPopup() {
      if (!modelInfoWindow || modelInfoWindow.closed || !rootContainer) return;

      const bounds = computeBounds(rootContainer);
      const modelData = {
        name: 'ì „ì²´ ëª¨ë¸',
        id: rootContainer.name || 'rootContainer',
        bounds: bounds ? {
          size: {
            x: bounds.size.x.toFixed(4),
            y: bounds.size.y.toFixed(4), 
            z: bounds.size.z.toFixed(4)
          },
          center: {
            x: bounds.center.x.toFixed(4),
            y: bounds.center.y.toFixed(4),
            z: bounds.center.z.toFixed(4)
          }
        } : null,
        transform: {
          position: {
            x: rootContainer.position.x.toFixed(4),
            y: rootContainer.position.y.toFixed(4),
            z: rootContainer.position.z.toFixed(4)
          },
          rotation: rootContainer.rotationQuaternion ? {
            x: (rootContainer.rotationQuaternion.toEulerAngles().x * 180 / Math.PI).toFixed(1),
            y: (rootContainer.rotationQuaternion.toEulerAngles().y * 180 / Math.PI).toFixed(1),
            z: (rootContainer.rotationQuaternion.toEulerAngles().z * 180 / Math.PI).toFixed(1)
          } : { x: 0, y: 0, z: 0 },
          scaling: {
            x: rootContainer.scaling.x.toFixed(3),
            y: rootContainer.scaling.y.toFixed(3),
            z: rootContainer.scaling.z.toFixed(3)
          }
        },
        currentMode: currentMode
      };

      modelInfoWindow.postMessage({
        type: 'modelData',
        data: modelData
      }, '*');
    }

    // ===== ì„¤ì • ê´€ë ¨ í•¨ìˆ˜ë“¤ =====
    let toolboxWindow = null; // ì„¤ì • íˆ´ë°•ìŠ¤ íŒì—… ì°¸ì¡°

    // ë°°ê²½ìƒ‰ ë³€ê²½
    function updateBackground(color) {
      console.log('Updating background color to:', color);
      try {
        const r = parseInt(color.slice(1,3), 16) / 255;
        const g = parseInt(color.slice(3,5), 16) / 255; 
        const b = parseInt(color.slice(5,7), 16) / 255;
        scene.clearColor = new BABYLON.Color4(r, g, b, 1);
        setLS('bgColor', color);
        console.log('Background color successfully changed to:', color);
      } catch(e) {
        console.error('Error updating background color:', e);
      }
    }

    // ê·¸ë¦¬ë“œ ì—…ë°ì´íŠ¸
    function updateGrid(options) {
      console.log('Updating grid with options:', options);
      
      if (options.visible !== undefined) {
        ground.setEnabled(options.visible);
        setLS('gridVis', options.visible);
        console.log('Grid visibility set to:', options.visible);
      }
      if (options.lineColor) {
        try {
          gridMat.lineColor = BABYLON.Color3.FromHexString(options.lineColor);
          setLS('gridLineColor', options.lineColor);
          console.log('Grid line color set to:', options.lineColor);
        } catch(e) {
          console.error('Error setting grid line color:', e);
        }
      }
      if (options.mainColor) {
        try {
          gridMat.mainColor = BABYLON.Color3.FromHexString(options.mainColor);
          setLS('gridMainColor', options.mainColor);
          console.log('Grid main color set to:', options.mainColor);
        } catch(e) {
          console.error('Error setting grid main color:', e);
        }
      }
      if (options.size) {
        try {
          const newSize = parseFloat(options.size);
          ground.dispose();
          ground = BABYLON.Mesh.CreateGround("grid", newSize, newSize, 2, scene);
          ground.material = gridMat;
          setLS('gridSize', newSize);
          console.log('Grid size set to:', newSize);
        } catch(e) {
          console.error('Error setting grid size:', e);
        }
      }
    }

    // ì¡°ëª… ì—…ë°ì´íŠ¸
    function updateLighting(options) {
      // Hemispheric light
      if (options.hemiVisible !== undefined) {
        const hemi = scene.getLightByName("hemi");
        if (hemi) hemi.setEnabled(options.hemiVisible);
        setLS('hemiToggle', options.hemiVisible);
      }
      if (options.hemiIntensity !== undefined) {
        const hemi = scene.getLightByName("hemi");
        if (hemi) hemi.intensity = options.hemiIntensity;
        setLS('hemiIntensity', options.hemiIntensity);
      }
      
      // Directional light
      if (options.dirVisible !== undefined) {
        const dir = scene.getLightByName("dir");
        if (dir) dir.setEnabled(options.dirVisible);
        setLS('dirToggle', options.dirVisible);
      }
      if (options.dirIntensity !== undefined) {
        const dir = scene.getLightByName("dir");
        if (dir) dir.intensity = options.dirIntensity;
        setLS('dirIntensity', options.dirIntensity);
      }

      // Sun light (ìƒˆë¡œ ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸)
      let sunLight = scene.getLightByName("sun");
      
      if (options.sunVisible !== undefined) {
        if (options.sunVisible) {
          if (!sunLight) {
            sunLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(0, -1, 0), scene);
            console.log('Created new sun light');
          }
          sunLight.setEnabled(true);
          
          if (options.sunIntensity !== undefined) {
            sunLight.intensity = options.sunIntensity;
            setLS('sunIntensity', options.sunIntensity);
            console.log('Sun intensity set to:', options.sunIntensity);
          }
          
          // íƒœì–‘ ìœ„ì¹˜ ê³„ì‚° (ë°©ìœ„ê°, ê³ ë„)
          if (options.sunAzimuth !== undefined || options.sunAltitude !== undefined) {
            const azimuth = (options.sunAzimuth !== undefined ? options.sunAzimuth : parseFloat(getLS('sunAzimuth', '135'))) * Math.PI / 180;
            const altitude = (options.sunAltitude !== undefined ? options.sunAltitude : parseFloat(getLS('sunAltitude', '35'))) * Math.PI / 180;
            
            const x = Math.cos(altitude) * Math.cos(azimuth);
            const y = -Math.sin(altitude);
            const z = Math.cos(altitude) * Math.sin(azimuth);
            
            sunLight.direction = new BABYLON.Vector3(x, y, z);
            
            if (options.sunAzimuth !== undefined) setLS('sunAzimuth', options.sunAzimuth);
            if (options.sunAltitude !== undefined) setLS('sunAltitude', options.sunAltitude);
            
            console.log('Sun direction set to:', x, y, z, 'azimuth:', options.sunAzimuth || parseFloat(getLS('sunAzimuth', '135')), 'altitude:', options.sunAltitude || parseFloat(getLS('sunAltitude', '35')));
          }
          
          // ê·¸ë¦¼ì ì„¤ì •
          if (options.sunShadows !== undefined) {
            if (options.sunShadows && !sunLight.getShadowGenerator()) {
              try {
                const shadowGenerator = new BABYLON.ShadowGenerator(1024, sunLight);
                shadowGenerator.useBlurExponentialShadowMap = true;
                shadowGenerator.blurKernel = 32;
                
                // ëª¨ë“  ë©”ì‹œì— ê·¸ë¦¼ì ìºìŠ¤í„° ì¶”ê°€
                if (rootContainer) {
                  rootContainer.getChildMeshes().forEach(mesh => {
                    shadowGenerator.addShadowCaster(mesh);
                  });
                }
                ground.receiveShadows = true;
                console.log('Sun shadows enabled');
              } catch(e) {
                console.error('Error setting up sun shadows:', e);
              }
            }
            setLS('sunShadows', options.sunShadows);
          }
          
          setLS('sunToggle', true);
          console.log('Sun light enabled');
        } else {
          if (sunLight) {
            sunLight.setEnabled(false);
            console.log('Sun light disabled');
          }
          setLS('sunToggle', false);
        }
      }
    }

    // ìŠ¤íƒ€ì¼ ì ìš©
    function applyStyle(styleData) {
      console.log('Applying style with data:', styleData);
      
      if (!rootContainer) {
        console.warn('No rootContainer found for style application');
        return;
      }
      
      const meshes = rootContainer.getChildMeshes();
      console.log('Found meshes for styling:', meshes.length);
      
      meshes.forEach((mesh, index) => {
        console.log(`Applying style to mesh ${index}: ${mesh.name}`);
        
        try {
          // ìœ¤ê³½ì„ /ì—ì§€
          if (styleData.useOutline !== undefined) {
            if (styleData.useOutline) {
              mesh.enableEdgesRendering();
              mesh.edgesWidth = styleData.outlineWidth || 0.02;
              mesh.edgesColor = BABYLON.Color4.FromHexString(styleData.outlineColor || '#111827');
              console.log(`Outline enabled for ${mesh.name}`);
            } else {
              mesh.disableEdgesRendering();
              console.log(`Outline disabled for ${mesh.name}`);
            }
          }
          
          // ì—ì§€ ë Œë”ë§ (ë³„ë„ ì„¤ì •)
          if (styleData.useEdges !== undefined) {
            if (styleData.useEdges) {
              mesh.enableEdgesRendering();
              mesh.edgesWidth = styleData.edgesWidth || 15;
              mesh.edgesColor = BABYLON.Color4.FromHexString(styleData.edgesColor || '#000000');
              console.log(`Edges enabled for ${mesh.name}`);
            } else if (!styleData.useOutline) {
              mesh.disableEdgesRendering();
              console.log(`Edges disabled for ${mesh.name}`);
            }
          }
          
          // ì¬ì§ˆì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì ìš©
          if (mesh.material) {
            // ì™€ì´ì–´í”„ë ˆì„
            if (styleData.useWire !== undefined) {
              mesh.material.wireframe = styleData.useWire;
              console.log(`Wireframe ${styleData.useWire ? 'enabled' : 'disabled'} for ${mesh.name}`);
            }
            
            // ì–‘ë©´ ë Œë”ë§
            if (styleData.useDouble !== undefined) {
              mesh.material.backFaceCulling = !styleData.useDouble;
              console.log(`Double-sided ${styleData.useDouble ? 'enabled' : 'disabled'} for ${mesh.name}`);
            }
            
            // PBR ì¬ì§ˆì¸ ê²½ìš°ë§Œ ìƒ‰ìƒ/ì¬ì§ˆ ì†ì„± ì ìš©
            if (mesh.material.albedoColor !== undefined) {
              if (styleData.baseColor) {
                mesh.material.albedoColor = BABYLON.Color3.FromHexString(styleData.baseColor);
                console.log(`Base color applied to ${mesh.name}: ${styleData.baseColor}`);
              }
              
              if (styleData.metallic !== undefined) {
                mesh.material.metallicFactor = styleData.metallic;
                console.log(`Metallic factor applied to ${mesh.name}: ${styleData.metallic}`);
              }
              
              if (styleData.roughness !== undefined) {
                mesh.material.roughnessFactor = styleData.roughness;
                console.log(`Roughness factor applied to ${mesh.name}: ${styleData.roughness}`);
              }
              
              if (styleData.emissiveColor) {
                mesh.material.emissiveColor = BABYLON.Color3.FromHexString(styleData.emissiveColor);
                console.log(`Emissive color applied to ${mesh.name}: ${styleData.emissiveColor}`);
              }
            }
          } else {
            console.warn(`No material found for mesh: ${mesh.name}`);
          }
        } catch(e) {
          console.error(`Error applying style to mesh ${mesh.name}:`, e);
        }
      });
      
      // ì„¤ì • ì €ì¥
      Object.keys(styleData).forEach(key => {
        setLS(key, styleData[key]);
      });
      
      console.log('Style application completed');
    }

    // í˜„ì¬ ì„¤ì •ì„ íˆ´ë°•ìŠ¤ì— ì „ì†¡
    function sendCurrentSettingsToToolbox() {
      if (!toolboxWindow || toolboxWindow.closed) return;
      
      const currentSettings = {
        bgColor: getLS('bgColor', '#0f1115'),
        gridVis: getLS('gridVis', 'true') === 'true',
        gridLineColor: getLS('gridLineColor', '#3a4153'),
        gridMainColor: getLS('gridMainColor', '#232531'),
        gridSize: getLS('gridSize', '10'),
        hemiToggle: getLS('hemiToggle', 'true') === 'true',
        hemiIntensity: getLS('hemiIntensity', '0.7'),
        dirToggle: getLS('dirToggle', 'true') === 'true',
        dirIntensity: getLS('dirIntensity', '1.0'),
        sunToggle: getLS('sunToggle', 'false') === 'true',
        sunIntensity: getLS('sunIntensity', '1.5'),
        sunAzimuth: getLS('sunAzimuth', '135'),
        sunAltitude: getLS('sunAltitude', '35'),
        sunShadows: getLS('sunShadows', 'true') === 'true'
      };
      
      toolboxWindow.postMessage({
        type: 'syncSettings',
        data: currentSettings
      }, '*');
    }

    // ===== íŒì—…ìœ¼ë¡œë¶€í„° ë©”ì‹œì§€ ìˆ˜ì‹  =====
    window.addEventListener('message', function(event) {
      console.log('Received message in main viewer:', event.data, 'from:', event.source);
      console.log('Message type:', typeof event.data, 'Keys:', Object.keys(event.data || {}));
      
      if (!event.data) return;
      
      const { type, data } = event.data;
      
      // ëª¨ë¸ ì •ë³´ íŒì—…ì—ì„œ ì˜¨ ë©”ì‹œì§€
      if (modelInfoWindow && event.source === modelInfoWindow) {
        switch(type) {
          case 'transformChange':
            applyTransformFromPopup(data);
            break;
          case 'modeChange':
            setMode(data.mode);
            break;
          case 'resetTransform':
            resetTransform();
            break;
          case 'focusModel':
            if (rootContainer) focusNode(rootContainer);
            break;
          case 'requestUpdate':
            sendModelInfoToPopup();
            break;
        }
      }
      
      // íˆ´ë°•ìŠ¤ íŒì—…ì—ì„œ ì˜¨ ë©”ì‹œì§€ (ì†ŒìŠ¤ ì²´í¬ ì™„í™”)
      if (!modelInfoWindow || event.source !== modelInfoWindow) {
        console.log('Processing potential toolbox message:', type, data);
        
        // íˆ´ë°•ìŠ¤ ìœˆë„ìš° ì°¸ì¡° ì—…ë°ì´íŠ¸ (ì²˜ìŒ ë©”ì‹œì§€ë¥¼ ë°›ì„ ë•Œ)
        if (!toolboxWindow || toolboxWindow.closed) {
          toolboxWindow = event.source;
          console.log('Updated toolboxWindow reference');
        }
        
        switch(type) {
          case 'to3DView':
            console.log('Nested message - processing:', data.type, data.data);
            handleToolboxMessage(data.type, data.data);
            break;
          case 'toolboxPopupReady':
            // íˆ´ë°•ìŠ¤ê°€ ì¤€ë¹„ë˜ë©´ í˜„ì¬ ì„¤ì • ì „ì†¡
            setTimeout(() => sendCurrentSettingsToToolbox(), 500);
            break;
          // ì§ì ‘ì ì¸ ë©”ì‹œì§€ë“¤ë„ ì²˜ë¦¬
          case 'updateBackground':
            console.log('Direct updateBackground message');
            updateBackground(data.color);
            break;
          case 'updateGrid':
            console.log('Direct updateGrid message');
            updateGrid(data);
            break;
          case 'updateLighting':
            console.log('Direct updateLighting message');
            updateLighting(data);
            break;
          case 'applyStyle':
            console.log('Direct applyStyle message');
            applyStyle(data);
            break;
          default:
            console.log('Unknown message type from toolbox:', type);
        }
      }
    });

    // íˆ´ë°•ìŠ¤ ë©”ì‹œì§€ ì²˜ë¦¬
    function handleToolboxMessage(messageType, messageData) {
      console.log('Handling toolbox message:', messageType, messageData);
      
      try {
        switch(messageType) {
          case 'updateBackground':
            updateBackground(messageData.color);
            break;
          case 'updateGrid':
            updateGrid(messageData);
            break;
          case 'updateLighting':
            updateLighting(messageData);
            break;
          case 'applyStyle':
            applyStyle(messageData);
            break;
          case 'setMode':
            setMode(messageData.mode);
            break;
          case 'loadModel':
            loadModelFromData(messageData);
            break;
          case 'resetScene':
            // ì”¬ ë¦¬ì…‹ ë¡œì§
            if (currentContainer) {
              gizmoManager.attachToMesh(null);
              currentContainer.removeAllFromScene();
              currentContainer.dispose();
              currentContainer = null;
            }
            removeAllBoundingBoxes();
            rootContainer.getChildren().forEach(c=>c.dispose());
            rootContainer = new BABYLON.TransformNode("rootContainer", scene);
            selectedModel = null;
            break;
          case 'focusMesh':
            if (rootContainer) focusNode(rootContainer);
            break;
          case 'requestMeshList':
            // ë©”ì‹œ ë¦¬ìŠ¤íŠ¸ ì „ì†¡
            if (toolboxWindow && !toolboxWindow.closed && rootContainer) {
              const meshes = rootContainer.getChildMeshes(false).map(m => ({
                name: m.name,
                id: m.id
              }));
              toolboxWindow.postMessage({
                type: 'meshListUpdate',
                data: { meshes }
              }, '*');
            }
            break;
          default:
            console.warn('Unknown toolbox message type:', messageType);
        }
      } catch (error) {
        console.error('Error handling toolbox message:', messageType, error);
      }
    }

    function applyTransformFromPopup(data) {
      if (!rootContainer) return;
      
      const { property, axis, value } = data;
      
      if (property === 'position') {
        rootContainer.position[axis] = value;
      } else if (property === 'rotation') {
        if (!rootContainer.rotationQuaternion) {
          rootContainer.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, 0, 0);
        }
        const e = rootContainer.rotationQuaternion.toEulerAngles();
        e[axis] = value * Math.PI / 180; // ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ
        rootContainer.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(e.y, e.x, e.z);
      } else if (property === 'scaling') {
        rootContainer.scaling[axis] = Math.max(0.001, value);
      }
      
      rootContainer.computeWorldMatrix(true);
      
      // ê²½ê³„ë°•ìŠ¤ ì—…ë°ì´íŠ¸
      if (modelBoundingBox) {
        showModelBoundingBox();
      }
      
      // íŒì—…ì— ì—…ë°ì´íŠ¸ëœ ì •ë³´ ë‹¤ì‹œ ì „ì†¡
      setTimeout(() => {
        sendModelInfoToPopup();
      }, 50);
    }

    function resetTransform() {
      if (!rootContainer) return;
      
      rootContainer.position.set(0, 0, 0);
      rootContainer.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, 0, 0);
      rootContainer.scaling.set(1, 1, 1);
      rootContainer.computeWorldMatrix(true);
      
      if (modelBoundingBox) {
        showModelBoundingBox();
      }
      
      sendModelInfoToPopup();
    }

    // ===== ê¸°íƒ€ ê¸°ì¡´ í•¨ìˆ˜ë“¤ =====
    async function loadModelFromData(modelData) {
      try {
        if (currentContainer) {
          gizmoManager.attachToMesh(null);
          currentContainer.removeAllFromScene();
          currentContainer.dispose();
          currentContainer = null;
        }
        removeAllBoundingBoxes();
        
        rootContainer.getChildren().forEach(c=>c.dispose());
        rootContainer = new BABYLON.TransformNode("rootContainer", scene);
        rootContainer.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, 0, 0);

        const byteCharacters = atob(modelData.content);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray]);
        const file = new File([blob], modelData.filename);

        BABYLON.FilesInputStore.FilesToLoad = {};
        BABYLON.FilesInputStore.FilesToLoad[modelData.filename.toLowerCase()] = file;

        const pluginExt = /\.glb$/i.test(modelData.filename) ? ".glb" : ".gltf";
        
        currentContainer = await BABYLON.SceneLoader.LoadAssetContainerAsync("file:", modelData.filename, scene, null, pluginExt);
        currentContainer.addAllToScene();

        const roots = currentContainer.meshes.filter(m => !m.parent);
        for (const r of roots) {
          attachKeepWorld(r, rootContainer);
        }

        rootContainer.computeWorldMatrix(true);
        
        let bounds = computeBounds(rootContainer);
        
        if (bounds) {
          let scale = 1.0;
          const maxDim = Math.max(bounds.size.x, bounds.size.y, bounds.size.z);
          
          if (maxDim > 10.0) {
            scale = 0.001;
          }
          
          rootContainer.scaling = new BABYLON.Vector3(scale, scale, scale);
          rootContainer.computeWorldMatrix(true);
          
          bounds = computeBounds(rootContainer);
          
          if (bounds) {
            const offset = new BABYLON.Vector3(-bounds.center.x, -bounds.min.y, -bounds.center.z);
            rootContainer.position.copyFrom(offset);
            rootContainer.computeWorldMatrix(true);
          }
        }

        attachGizmoToModel();
        focusNode(rootContainer);
        selectedModel = rootContainer;
        
        // ëª¨ë¸ ì •ë³´ íŒì—…ì´ ì—´ë ¤ìˆë‹¤ë©´ ì—…ë°ì´íŠ¸
        if (modelInfoWindow && !modelInfoWindow.closed) {
          sendModelInfoToPopup();
        }

      } catch(err) {
        console.error('Model load error:', err);
      }
    }

    async function loadFilesDirectly(fileList) {
      if (!fileList || fileList.length === 0) return;
      
      try {
        if (currentContainer) {
          gizmoManager.attachToMesh(null);
          currentContainer.removeAllFromScene();
          currentContainer.dispose();
          currentContainer = null;
        }
        removeAllBoundingBoxes();
        
        rootContainer.getChildren().forEach(c=>c.dispose());
        rootContainer = new BABYLON.TransformNode("rootContainer", scene);

        BABYLON.FilesInputStore.FilesToLoad = {};
        let mainFile = null;
        
        for (const f of fileList) {
          BABYLON.FilesInputStore.FilesToLoad[f.name.toLowerCase()] = f;
          if (!mainFile && (/\.(glb|gltf)$/i).test(f.name)) mainFile = f;
        }
        
        if (!mainFile) {
          alert("GLB ë˜ëŠ” GLTF íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
          return;
        }

        const pluginExt = /\.glb$/i.test(mainFile.name) ? ".glb" : ".gltf";
        
        currentContainer = await BABYLON.SceneLoader.LoadAssetContainerAsync("file:", mainFile.name, scene, null, pluginExt);
        currentContainer.addAllToScene();

        const roots = currentContainer.meshes.filter(m => !m.parent);
        for (const r of roots) {
          attachKeepWorld(r, rootContainer);
        }

        rootContainer.computeWorldMatrix(true);
        
        let bounds = computeBounds(rootContainer);
        
        if (bounds) {
          let scale = 1.0;
          const maxDim = Math.max(bounds.size.x, bounds.size.y, bounds.size.z);
          if (maxDim > 10.0) {
            scale = 0.001;
          }
          
          rootContainer.scaling = new BABYLON.Vector3(scale, scale, scale);
          rootContainer.computeWorldMatrix(true);
          
          bounds = computeBounds(rootContainer);
          
          if (bounds) {
            const offset = new BABYLON.Vector3(-bounds.center.x, -bounds.min.y, -bounds.center.z);
            rootContainer.position.copyFrom(offset);
            rootContainer.computeWorldMatrix(true);
          }
        }

        attachGizmoToModel();
        focusNode(rootContainer);
        selectedModel = rootContainer;
        
        // ëª¨ë¸ ì •ë³´ íŒì—…ì´ ì—´ë ¤ìˆë‹¤ë©´ ì—…ë°ì´íŠ¸
        if (modelInfoWindow && !modelInfoWindow.closed) {
          sendModelInfoToPopup();
        }
        
        console.log(`ëª¨ë¸ ë¡œë“œ ì™„ë£Œ: ${mainFile.name}`);
        
      } catch(err) {
        console.error('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', err);
        alert('ëª¨ë¸ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
      }
    }

    // ===== ì´ˆê¸° ì„¤ì • ë³µì› =====
    function restoreInitialSettings() {
      // ë°°ê²½ìƒ‰ ë³µì›
      const bgColor = getLS('bgColor', '#0f1115');
      updateBackground(bgColor);
      
      // ê·¸ë¦¬ë“œ ì„¤ì • ë³µì›
      const gridVis = getLS('gridVis', 'true') === 'true';
      const gridLineColor = getLS('gridLineColor', '#3a4153');
      const gridMainColor = getLS('gridMainColor', '#232531');
      const gridSize = parseFloat(getLS('gridSize', '10'));
      
      updateGrid({
        visible: gridVis,
        lineColor: gridLineColor,
        mainColor: gridMainColor,
        size: gridSize
      });
      
      // ì¡°ëª… ì„¤ì • ë³µì›
      const lightingSettings = {
        hemiVisible: getLS('hemiToggle', 'true') === 'true',
        hemiIntensity: parseFloat(getLS('hemiIntensity', '0.7')),
        dirVisible: getLS('dirToggle', 'true') === 'true',
        dirIntensity: parseFloat(getLS('dirIntensity', '1.0')),
        sunVisible: getLS('sunToggle', 'false') === 'true',
        sunIntensity: parseFloat(getLS('sunIntensity', '1.5')),
        sunAzimuth: parseFloat(getLS('sunAzimuth', '135')),
        sunAltitude: parseFloat(getLS('sunAltitude', '35')),
        sunShadows: getLS('sunShadows', 'true') === 'true'
      };
      
      console.log('Restoring lighting settings:', lightingSettings);
      updateLighting(lightingSettings);
    }

    // ===== ë Œë”ë§ ì‹œì‘ =====
    engine.runRenderLoop(()=> scene.render());
    window.addEventListener('resize', ()=> engine.resize());

    // ì´ˆê¸° ì„¤ì • ì ìš©
    restoreInitialSettings();

    // ===== íŒŒì¼ ë¡œë”© ê¸°ëŠ¥ =====
    const fileInput = document.getElementById('fileInput');
    const modelInfoBtn = document.getElementById('modelInfoBtn');
    const settingsBtn = document.getElementById('settingsBtn');

    fileInput.addEventListener('change', async (e) => {
      const files = e.target.files;
      if (files && files.length) {
        await loadFilesDirectly(files);
      }
      e.target.value = '';
    });

    modelInfoBtn.addEventListener('click', function() {
      toggleModelInfoPopup();
    });

    settingsBtn.addEventListener('click', function() {
      if (toolboxWindow && !toolboxWindow.closed) {
        // ì´ë¯¸ ì—´ë ¤ìˆìœ¼ë©´ í¬ì»¤ìŠ¤
        toolboxWindow.focus();
        return;
      }
      
      toolboxWindow = window.open(
        'viewer-toolbox.html', 
        'toolbox', 
        'width=400,height=800,scrollbars=yes,resizable=yes,left=' + (window.screenX + window.outerWidth) + ',top=' + window.screenY
      );
      
      if (toolboxWindow) {
        toolboxWindow.addEventListener('load', function() {
          setTimeout(() => {
            // í˜„ì¬ ì„¤ì • ë™ê¸°í™”
            sendCurrentSettingsToToolbox();
            
            // ë©”ì‹œ ë¦¬ìŠ¤íŠ¸ ì „ì†¡
            if (rootContainer) {
              const meshes = rootContainer.getChildMeshes(false).map(m => ({
                name: m.name,
                id: m.id
              }));
              toolboxWindow.postMessage({
                type: 'meshListUpdate',
                data: { meshes }
              }, '*');
            }
          }, 1000);
        });
      } else {
        alert('íŒì—…ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ íŒì—…ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
      }
    });

    // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì§€ì›
    document.addEventListener('dragover', function(e) {
      e.preventDefault();
    });

    document.addEventListener('drop', function(e) {
      e.preventDefault();
      const files = e.dataTransfer?.files;
      if (files && files.length) {
        loadFilesDirectly(files);
      }
    });
  </script>
</body>
</html>